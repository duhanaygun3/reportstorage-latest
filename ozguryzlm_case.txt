Backend
Projenin backend kısmında Varlıkların bulunduğu "entities", controllerların bulunduğu "webapi", Repository implementasyonlarını JpaRepository üzerinden yapılan "dataAccess",İş kurallarını çalıştırdığım "business" ve Mapperların bulunduğu "core" dosyaları bulunmakta. Her entity için repository nesnesi oluşturulmuştur. Business katmanında ise yapılan her işlemin sonucu JpaRepository'nin kabileyetlerini kullanarak veritabanı işlemlerini yapmaktadır. Bussiness işlemlerini yaptırmak için her entity için ayri "Interface" servisi oluşturulmuştur ve her entity için oluşturulmuş "Manager" classları bu "Interface" leri implemente ediyor. Aynı zamanda "Business katmanında "Response" ve "Request" olarak iki ayrım mevuct. Burdaki Nesneler Her yapılan isteğe göre Dto Nesnelerine denk geliyor. "GET","POST" VE "PATCH" metodları için kullanılan bu DTO nesneleri aynı zamanda okunabilirliği de arttırmayı amaçlamaktadır."DELETE"işlemler "id" üzerinden yapılıyor. Burdaki dönüşümlerde "Mapper" kullanılarak "DTO" işlemleri otomize edilmiştir. Mapper'ın "Request" ve "Response" lar için Config ayarları da bulunmakta. İhtiyaç gereği "Report" ile ilgili business katmanında "ReportService" in diğer servislerle iletişimde olması gerekiyor. Bunun için diğer servislerin tüm fonksiyonlarını kullanıma açmak yerine "ReportFacede" adında bir servis açılmış ve "ReportService" in kullanımına verilecek fonksiyonlar tanımlanmıştır. "webapi" kısmında api işlemlerimizi yapıyoruz. Her nesneye ait Apiler farklı request mappingler ile ayrılmış ve buraki her endpoint DTO nesnesini alarak "business"katmanına ulaşmakta.


DataBase
Db olarak PostgreSQL kullanıldı. Diğer sistemlerle daha önce tecrübem olmadığı için ve backend ile bağlantıyı kurması nispeten daha kolay olduğunu düşündüğüm için PostgreSQL tercih ettim.
Proje içerisinde java klasörü içerisinde bulunann resources klasörünün içerisinde db bağlantılarını ve ayarlamaları bulunun "aplication.properties" dosyası bulunur. Projenini bu aşamsında sadece bir tane bulunan bu dosya daha sonrasında "Docker image" oluştururulurken geliştirme ortamı ve docker ortamı olmak üzere ikiye ayrılmış (datasource.url bağlantıyı farklı adresten yapma gereği duyuyor). DataBase de tabloların oluşturulması entity'ler üzerinde "TableName", "ColumnName" anotasyonları, bu değişkenlere ait "constrait"ler "Column" içerisinde belirtilerek oluşturuldu. Proje ayağa kaldırıldığında Db ye bağlanarak gerekli tabloların var olup olmadığını kontrol eder. Eğer yok ise oluşturur.

Test
Kısmı bir şekilde birim test yapmak amacıyla en karmaşık olan "ReportService" e hem bir "void" methodun hem de geriye bir "Report" nesnesini başarı ile dönen ve başarısız olan toplamda 3 adet test bulunmaktadır.Mockito kütüphanesi ile servislerin davranışları ve geri dönüş değerleri belirlemiş olup en sonda "assert" ile beklenen sonuç ve asıl sonuç arasındaki karşılaştırmalar yapılmış Testlere ait Arrange (Hazırla), Act (Eylem), Assert (Doğrula) aşamaları işaretlenmiş ve kod üzerinde açıklamalarla desteklenmiştir.

Frontend
Frontend'e ait dosyalar "laborant-fe" içinde bulunmakta. Frontend başlangıcında Report nesnesini listeleyen apiye bağlanıyoruz. Report Controllerina ait "Add Report","Edit Report","Delete Reprot" apileri bulunmakta ve çalışmaktadır. "App.js" dosyası içersinde bu sayfaylara ulaşabilmemize olanak sağlayan route'lar bulunuyor ve açılış sayfası Reportların listlendiği sayfa. "EditReport.js" ve "AddReport.js" dosyaları da bulunmakta. Bu işlemler burada gerçekleştirildi. Api bağlantıları "Axios" üzerinden yapıldı.


Docker

Projenin Ide'den bağımsız çalışmasını sağlamak için Docker container yapısını kullandım. Projenini kök dosyasında bulunan "Dockerfile" Springboot projesinin -jar dosyasını oluşturup docker image yaratılmasını sağlıyor. Benzer şekilde ./laborant-fe içinde bulunan "Dockerfile.react" ise react projesinin image dosyasının oluşturulmasını sağlıyor. Bütün projeyi tek bir komutla ayağa kaldırmak için ./integration dosyası içerisindeki "Docker-compose.yml" kullanılıyor. Burda üç yapının "Springboot", "Postgre", "React" yapılarının birbiri ile haberleşmesi için gerekli network yapılandırması, port ayarlamaları, kullanılacak dockerfile'lar oluşacak image isimlendirmeleri belirlenmiştir. Projeyi çalıştırmak isteyen bu dosya üzerinden çalıştırmayı tek işlemde yapabilir. 